(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{362:function(t,e,a){"use strict";a.r(e);var r=a(33),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"event-loop-与异步更新策略-从event-loop中着手性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-与异步更新策略-从event-loop中着手性能优化"}},[t._v("#")]),t._v(" Event Loop 与异步更新策略(从Event Loop中着手性能优化)")]),t._v(" "),a("blockquote",[a("p",[t._v("Micro-Task 与 Macro-Task")]),t._v(" "),a("blockquote",[a("p",[t._v("事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。"),a("br"),t._v("\n常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。"),a("br"),t._v("\n常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。")])])]),t._v(" "),a("h2",{attrs:{id:"每一次循环都是一个这样的过程："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#每一次循环都是一个这样的过程："}},[t._v("#")]),t._v(" 每一次循环都是一个这样的过程：")]),t._v(" "),a("p",[t._v("将一个macro-task执行并出队 =》将一队micro-task执行并出队 =》 执行渲染操作，更新界面=》处理worker相关的任务")]),t._v(" "),a("h2",{attrs:{id:"渲染的时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染的时机"}},[t._v("#")]),t._v(" 渲染的时机")]),t._v(" "),a("p",[t._v("我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择。")]),t._v(" "),a("h2",{attrs:{id:"异步更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步更新策略"}},[t._v("#")]),t._v(" 异步更新策略")]),t._v(" "),a("p",[t._v("当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被批量触发。这就是异步更新。")])])}),[],!1,null,null,null);e.default=s.exports}}]);